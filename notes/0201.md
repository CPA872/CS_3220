## Verilog Introduction 

### Components, general module structure
`module` Name

- Port List, Port Declarations
- Parameters (optional)
- Declarations of wires, regs and other vars
- instantiation of lower level modules
- `assign` data flow statement
- `always` and `initial` blocks, all behavioral statements go in these blocks

- Tasks and Functions

`endmodule`

### Example XOR in verilog

```verilog
module myxor(c, a, b);  // "Definition"
    output c;
    input a, b;
    wire nota, notb, anotb, bnota;

    not(nota, b); // not is a primitive module
    not(notb, b); // not(out_signal, in_signal)

    and(anotb, a, notb);
    and(bnota, b, nota);
    or (c, anotb, bnota);
endmodule
```

### Number system

0 1 X(unknow), z(high impedence)

```verilog
X = 4'b1010   <size>'<base><value>

8'hAF'

{4'hA, 4'b1111} == {4'ha, {4{1'b1}}} == 5'hAF

```

### Register v.s. Wire
Wire

- represents connection between components
- Value is determined by Drivers
- Default value is Z

Reg

- Retains its value until next assignments
- Default value is X
- DOES NOT reflect read registers

### Tenary Expressions

`assign addr_bus = drive_enable ? addr_out : 36'b`

### Continuous Assignments
`assign   `     dsf

Implicit declaration:

`wire out; assign out = in1 & in2`

is equivalant to 

`wire out = in1 & in2`

Only one implicit declaration assignment per wire

### Always Statements

You cannot use wires in always

```verilog 
always @(posedge clock) // positive edge trigger`
    #10 // delay 10 clocks
    do things

always @(*) // WHENEVER input values change

always @(clock)


```

## Simulation, Testbench

- Behavioral Simulation
  - 